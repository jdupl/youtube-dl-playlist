#!/usr/bin/python3
# youtube-dl-playlist
#
# Utility to download Youtube playlist videos.
# Forked to support python 3 and keep playlist's video order.
#
# @author Jordon Mears <jordoncm at gmail dot com>
# @author Justin Duplessis <duplessisjustin1 at gmail dot com>
# @license LGPL version 2 or greater <http://www.gnu.org/licenses/lgpl.html>

import sys
import urllib.request
import http.client
import json
import os
import glob


class PlaylistDownloader:
    targetDir = ''
    totalVideos = 0
    downloaded = 0

    def setTarget(self, target):
        self.targetDir = os.path.realpath(target) + '/'
        return self.targetDir

    def download(self, playlistId):
        print('Getting playlist information ...')
        data = self.fetchInfo(playlistId)
        self.totalVideos = int(data['feed']['openSearch$totalResults']['$t'])
        print('Total videos to download: %d'.format(self.totalVideos))
        title = data['feed']['title']['$t']
        playlistDir = self.createPath(self.targetDir, title)
        os.chdir(self.setTarget(playlistDir))

        self.downloaded = 1
        while(self.downloaded <= self.totalVideos):
            data = self.fetchInfo(playlistId, self.downloaded, 50)
            self.downloadEntires(data['feed']['entry'])

    def downloadEntires(self, entries):
        for entry in entries:
            group = entry['media$group']
            if self.downloadEntry(group['yt$videoid']['$t'],
            group['media$title']['$t']):
                self.downloaded = self.downloaded + 1

    def downloadEntry(self, ytId, ytTitle):
        print("%s(%s) %s".format(ytId, str(self.downloaded).zfill(3), ytTitle))

        existing = glob.glob('*' + ytId + '.*')
        filtered = [x for x in existing if not x.endswith('part')]
        if filtered.__len__() > 0:
            print('alreary exists, skipping...')
            return True

        try:
            os.system("""youtube-dl -t --audio-format=best
            http://www.youtube.com/watch?v=""" + ytId)
            return True

        except KeyboardInterrupt:
            sys.exit(1)

        except Exception as e:
            print('failed: %s'.format(e.strerror))
            return False

    def fetchInfo(self, playlistId, start=1, limit=0):
        connection = http.client.HTTPConnection('gdata.youtube.com')
        connection.request('GET', '/feeds/api/playlists/' + str(playlistId) +
        '/?' + urllib.parse.urlencode({
                'alt': 'json',
                'max-results': limit,
                'start-index': start,
                'v': 2
            }))

        response = connection.getresponse()
        if response.status != 200:
            print('Error: Not a valid/public playlist.')
            sys.exit(1)

        data = response.read()
        data = json.loads(data)
        return data

    def createPath(self, path, title):
        title = title.replace('/', '')
        number = ''

        if (os.path.exists(path + title) is True and
         os.path.isdir(path + title) is False):
            while(os.path.exists(path + title + str(number)) is True and
             os.path.isdir(path + title + str(number)) is False):
                if number == '':
                    number = 0
                number = number + 1

        if os.path.exists(path + title + str(number)) is False:
            os.mkdir(path + title + str(number))

        return path + title + str(number)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print('Usage: youtube-dl-playlist PLAYLIST_ID [DESTINATION_PATH]')
        sys.exit(1)
    else:
        if sys.argv[1][0] == 'P' and sys.argv[1][1] == 'L':
            PLAYLIST_ID = sys.argv[1][2:]
        else:
            PLAYLIST_ID = sys.argv[1]
    downloader = PlaylistDownloader()
    if len(sys.argv) == 3:
        downloader.setTarget(sys.argv[2] + '/')
    else:
        downloader.setTarget('./')
    downloader.download(PLAYLIST_ID)
